#!/bin/bash
#
# NAME
#	analyze_md_run -- analyze a completed MD run
#
# SYNOPSIS
#	analyze_md_run simulation
#
# DESCRIPTION	
#	simulation is the base name used to create all of a run output
#	files.
#
#	analyze_md_run will look for all the files generated by an MD
#	simulation and try to run a large battery of analysis tests on
#	them.
#
#	The tests include:
#		Generation of auxiliary indexes
#		Generation of auxiliary trajectories for solute alone
#		Fitting the system to itself
#		Graph of potential energy evolution
#		Graph of kinetic energy evolution
#		Graph of total energy evolution
#		Graph of pressure evolution
#		Graph of temperature evolution
#		Backbone RMSD with respect to original conformation
#		Ligand RMSD with respect to original conformation
#		Backbone RMSF during the trajectory
#		Side chain RMSF during the trajectory
#		Ligand RMSF during the trajectory
#		Backbone radius of gyration
#		Secondary structure changes
#		Clusterize trajectory and output central structures in each
#			cluster for the system and for the solute
#		TO BE ADDED: compute H-bonds between protein and ligands
#
# AUTHOR
#	JosÂ´e R. Valverde, CNB/CSIC. jrvalverde@cnb.csic.es, 2014
#
#	Licensed under (at your option) either GNU/GPL or EUPL
#
# LICENSE:
#
#	Copyright 2014 JOSE R VALVERDE, CNB/CSIC.
#	Copyright 2018 JOSE R VALVERDE, CNB/CSIC.
#
#	EUPL
#
#       Licensed under the EUPL, Version 1.1 or \u2013 as soon they
#       will be approved by the European Commission - subsequent
#       versions of the EUPL (the "Licence");
#       You may not use this work except in compliance with the
#       Licence.
#       You may obtain a copy of the Licence at:
#
#       http://ec.europa.eu/idabc/eupl
#
#       Unless required by applicable law or agreed to in
#       writing, software distributed under the Licence is
#       distributed on an "AS IS" basis,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
#       express or implied.
#       See the Licence for the specific language governing
#       permissions and limitations under the Licence.
#
#	GNU/GPL
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
cp $0 .

LIB=`dirname ${BASH_SOURCE[0]}`	# located within our same directory

source $LIB/include.bash

include util_funcs.bash
include gmx_setup_cmds.bash
include gmx_fix_multichain_xvg.bash
alias fixMcXvg=gmx_fix_multichain_xvg
include gmx_full_trr_to_xtc.bash
alias trr_to_xtc=gmx_full_trr_to_xtc
include gmx_xtc_last_time.bash
alias xtc_last_time=gmx_xtc_last_time
include gmx_trr_struct_at.bash
alias trr_struct_at_t=gmx_trr_struct_at
include gmx_xtc_struct_at.bash
alias xtc_struct_at_t=gmx_xtc_struct_at
include gmx_xtc_fit.bash
alias xtc_fit=gmx_xtc_fit
include gmx_xtc_fix_pbc.bash
alias xtc_fix_pbc=gmx_xtc_fix_pbc
include gmx_xtc_remove_solvent.bash
alias xtc_remove_solvent=gmx_xtc_remove_solvent
include gmx_xtc_analyze_covariance.bash
alias xtc_analyze_covariance=gmx_xtc_analyze_covariance
include gmx_xvg_plot.bash
alias xvg2img=gmx_xvg2img
include gmx_xtc_analyze_chi.bash
alias xtc_analyze_chi=gmx_xtc_analyze_chi
include gmx_xtc_plot_evolution.bash
alias xtc_plot_evolution=gmx_xtc_plot_evolution
include gmx_xtc_compute_rmsd.bash
alias xtc_compute_rmsd=gmx_xtc_compute_rmsd
include gmx_xtc_compute_rmsf.bash
alias xtc_compute_rmsf=gmx_xtc_compute_rmsf
include gmx_xtc_compute_gyr_acf.bash
alias xtc_compute_gyr_acf=gmx_xtc_compute_gyr_acf
include gmx_xtc_compute_secondary_structure.bash
alias xtc_compute_secondary_structure=gmx_xtc_compute_secondary_structure
include gmx_xtc_cluster.bash
alias xtc_cluster=gmx_xtc_cluster
include gmx_xtc_compute_sas.bash
alias xtc_compute_sas=gmx_xtc_compute_sas
include gmx_gro2pdb.bash
alias gro2pdb=gmx_gro2pdb
include gmx_make_ext_index.bash
alias make_ext_index=gmx_make_ext_index


function gmx_xtc_analyze_ligands {
# THIS FUNCTION NEEDS CAREFUL REVIEW (*** JR ***)
    md="$1"
    ligands="$2"
    
    # count H-bonds (protein vs. ligands)
    #	Luckily, when the Complex is generated a group named 'Other'
    #	is generated that includes all non-protein elements (without solvent)
    #
    # $ligands is a file listing in each line one ligand with its charge
    if [ -s $ligands ] ; then
        echo ""
        echo ">>> Analyzing ligands and ligand interactions"
        echo ""

	#
        # ligand (non-protein) RMSD and RMSF
    	#
	if [ ! -e ${md}_nonprot_rmsd.xvg ] ; then
            $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsd.xvg -tu ns <<END
non-Protein
non-Protein
END
	    $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsd.SVG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	    $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsd.PNG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	fi
        if [ ! -e ${md}_nonprot_rmsf.xvg ] ; then
            echo "non-Protein"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsf.xvg -oq ${md}_nonprot_rmsf.pdb
            $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsf.SVG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
            $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsf.PNG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
	fi
        
        while read lig charge ; do
            # for each ligand
            if [ ! -e ${md}_${lig}_rmsd.xvg ] ; then
                $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsd.xvg -tu ns <<END
$lig
$lig
END
	        $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsd.SVG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	        $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsd.PNG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	    fi
            if [ ! -e ${md}_${lig}_rmsf.xvg ] ; then
                echo "$lig"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsf.xvg -oq ${md}_${lig}_rmsf.pdb
                $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsf.SVG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
                $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsf.PNG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
	    fi
        done <$ligands
        

	#
        # H-bonds between Protein and ligands
        #
        $g_hbond -f $md.xtc -s $md.tpr \
	        -num ${md}_hbnum.xvg -ac ${md}_hbac.xvg \
                <<END
Protein
Other
END
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbnum.SVG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbnum.PNG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbac.SVG ${md}_hbac.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbac.PNG ${md}_hbac.xvg -pexec 'runavg(S0,100)'

        # for each ligand
        #
        #	XXX JR XXX HACK HACK HACK HACK HACK HACK
        #
        #	WE HAVE A PROBLEM if Solvent has been used:
        #	gromacs duplicates the ligand groups, and so we cannot
        #	select them independently by name
        #
        #	On the other hand: the motivating behaviour is
        #	a known bug in Gromacs that has been assigned
        #	low priority because groups can still be selected
        #	by number.
        #
        #	use $md_complex.gro if it exists (implies solvent existed)
        #	  to make an index file without solvent interference
        #	else use $md.ndx instead (if there is no solvent there is no problem)
        #
        #	We could use the index of Complex_b4ion.pdb or Complex.pdb as a guide
        #	instead. This works because solvent is added AFTER the original 
        #	Complex and, so, the coordinate offsets in Complex.pdb are preserved.
        #	But that would imply using a hardcoded value and is a 'no-no'.
        #
        grep -q "^\[ SOL" $md.ndx
        if [ $? -eq 0 ] ; then
            echo "q" | $make_ndx -f ${md}_complex.pdb -o ${md}_complex.ndx
            ndx=${md}_complex.ndx
        else
            ndx=$md.ndx
        fi
        #
        while read lig charge ; do
            if [ ! -e ${md}_hb_${lig}_num.xvg ] ; then
                $g_hbond -f $md.xtc -s $md.tpr -n $ndx\
	                -num ${md}_hb_${lig}_num.xvg -ac ${md}_hb_${lig}_ac.xvg \
                        <<END
Protein
$lig
END
    	        $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_num.SVG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
    	        $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_num.PNG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_ac.SVG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_ac.PNG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
	    fi
        done < $ligands

	#
        # Solvent Accessible Surface Area and volume
        #
	
        # we need different commands for Protein and Protein+ligans
        if [ -s Ligands.pdb ] ; then
            # create an index of protein plus all ligands
            #	This works because group Other was created before addition
            #	of water and contains only the ligands with no solvent
            $make_ndx  -f ${md}.tpr -o pro+lig.ndx <<END
"Protein"|"Other"
q
END
            # use the extended group to compute an "extended" protein
            # surface area (protein + ligands)
            $g_sas -s ${md}.tpr -f ${md}.xtc -o ${md}_complex_sasa.xvg -tv ${md}_complex_vol.xvg \
    	        -n pro+lig.ndx <<END
Protein_Other
Protein_Other
END
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_sasa.SVG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_sasa.PNG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_vol.SVG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_vol.PNG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
	fi

    fi
}





function analyze_md_run {
    # arguments: MD run base name
    # requirements:
    #	$md.tpr		-- topology file
    #   $md.gro         -- final coordinates	(optional)
    #	$md.trr		-- original trajectory file
    #	$md.xtc		-- low-res trajectory file	(optional)
    #   ${md}_noPBC.xtc	-- low-res trajectory corrected for PBC	(optional)
    #	$md.edr		-- energy evolution	
    #
    #	Complex_water.pdb if water was used in the simulation
    #
    local md=$1
    local ligands=${2:-LIGANDS.ok}
    
    echo ""
    boldblue "analyze_md_run: Analyzing MD run: $md"
    echo ""
    
    # Minimization runs do not generate trajectories
    if [ ! -e $md.trr ] ; then
    	boldred "analyze_md_run ERROR: No trajectory found for MD run \"$md\"."
        return
    fi
    if [ -e ${md}.analyzed ] ; then
        boldblue "analyze_md_run: MD run \"${md}\" is already analyzed"
        boldblue "analyze_md_run: remove file $md.analyzed to re-analyze"
        return
    fi
    
    # ensure we have definitions of solute, solvent and chains
    if [ ! -e $md.ndx ] ; then
        boldblue "Building index"
        gmx_make_ext_index "$md"
    fi
    
    boldblue "Creating XTC file"
    if [ ! -e "${md}.xtc" ] ; then
	    # convert to XTC and save last time as $md.lastt
	    gmx_trr_to_xtc "$md"
    fi
	# save last time registered in the trajectory
    if [ ! -e "${md}.lastt" ] ; then
	     # save trajectory last time to $md.lastt
	    gmx_xtc_last_time "$md"
    fi
    # get last time in the trajectory
    lastt=`cat "$md.lastt"`

    # get last configuration if not present from high-res trajectory
    if [ ! -e ${md}_last.gro ] ; then
	    gmx_trr_struct_at "$md" "-1"
		if [ ! -e "$md.gro" ] ; then ln "${md}_last.gro" "${md}.gro" ; fi
    fi
    
    # fit trajectory using first frame as reference
	# and save as ${md}_fit.xtc
    if [ ! -e ${md}_fit.xtc ] ; then
	    gmx_xtc_fit "$md"
    fi
    
    # correct trajectory for PBC if needed
	# generating ${md}_noPBC.xtc and ${md}_noPBC.tpr
    if [ ! -e ${md}_noPBC.xtc ] ; then
	    gmx_xtc_fix_pbc "$md"
    fi


    # Remove solvent (will do it with ${md}_noPBC (see function above)
	# and save first and last configurations of the solvent-free complex
	if [ ! -e "${md}_complex.xtc" ] ; then
	    gmx_xtc_remove_solvent "$md"
	fi
	
    boldblue "Fitting system to itself"
    if [ ! -e ${md}_complex_fit.xtc ] ; then
        gmx_xtc_fit "${md}_complex"
    fi
    
    gmx_xtc_analyze_covariance "$md"
	#-comp -rmsf -eig -proj -2d -3d #-extr
	#gmx analyze
    
    # check for ring flips (e.g. Phe/Tyr)
    gmx_xtc_analyze_chi "$md"    


    # Compute various graphs
    gmx_xtc_plot_evolution "$md"

    #	1. RMSD (movement w.r.t. original conformation)
    #	Show structural stability using ns as time unit
    gmx_xtc_compute_rmsd "${md}_complex_fit"

    #	2. RMSF (movility per atom/residue)
    #	    
    gmx_xtc_compute_rmsf "${md}_complex_fit"
	

    #	3. Radius of gyration (compactness and stability of the structure)
    #	backbone
    # The radius of gyration of a protein is a measure of its compactness. If a 
    # protein is stably folded, it will likely maintain a relatively steady value 
    # of R_g. If a protein unfolds, its R_g will change over time. 
    #
    gmx_xtc_compute_gyr_acf "$md_complex"
    
	
    
    #	4. Compute secondary structure changes
    #
    gmx_xtc_compute_secondary_structure "${md}_complex"

    #	5. Clusterize trajectory and output central structures in
    #	each cluster.
    #g_cluster -s md_complex.tpr -f md_complex.trr -dist rmsd-distribution.xvg \
    #	-o clusters.xpm -sz cluster-sizes.xvg -tr cluster-transitions.xpm \
    #        -ntr cluster-transitions.xvg -clid cluster-id-over-time.xvg \
    #        -cl clusters.pdb -cutoff 0.25 -method gromos -dt 10 [ -av ]
    gmx_xtc_cluster "$md"
	
    # protein surface area
    gmx_xtc_compute_sas "$md"
 
    # for all ligands
    gmx_xtc_analyze_ligands "$md" "$ligands"

    boldblue "Doing any remaining plot"
    # Last resort to ensure all XVG files are plotted
    for x in *.xvg ; do 
        gmx_xvg2img $x
    done

    touch ${md}.analyzed

    boldblue "DONE"
}


if [ "$LIBRARY"="no" ] ; then
    if [ $# -eq 0 ] ; then
	echo "Usage: "`basename $0`" trajectory [ligands]"
	exit
    elif [ $# -eq 1 ] ; then
        # should we strip the last part after a hypothetical dot just in case?
        trajectory="$1"
        ligands=''
    else
        trajectory="$1"
	ligands="$2"
    fi
    
    LIBRARY="yes"
    BASE=~/work/lenjuanes/script
    #BASE=`dirname $0`
	. $BASE/setup_cmds.sh
    . $BASE/make_ext_index.sh
    

    if [ ! -s ${trajectory}.trr ] ; then
	echo "MD trajectory $md.trr does not exist!"
	exit
    fi


    # work on a subdirectory
    mkdir "${trajectory}_analysis"
    cd "${trajectory}_analysis"
    for i in ../$trajectory.* ../${trajectory}_noPBC* ; do
	    if [ ! -s $i ] ; then continue ; fi
        if [ ! -e `basename $i` ] ; then
	    ln -s $i `basename $i`
 	fi
    done
     
    analyze_md_run $*

    cd ..
fi
