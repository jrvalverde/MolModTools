#!/bin/bash
#
# NAME
#	analyze_md_run -- analyze a completed MD run
#
# SYNOPSIS
#	analyze_md_run simulation
#
# DESCRIPTION	
#	simulation is the base name used to create all of a run output
#	files.
#
#	analyze_md_run will look for all the files generated by an MD
#	simulation and try to run a large battery of analysis tests on
#	them.
#
#	The tests include:
#		Generation of auxiliary indexes
#		Generation of auxiliary trajectories for solute alone
#		Fitting the system to itself
#		Graph of potential energy evolution
#		Graph of kinetic energy evolution
#		Graph of total energy evolution
#		Graph of pressure evolution
#		Graph of temperature evolution
#		Backbone RMSD with respect to original conformation
#		Ligand RMSD with respect to original conformation
#		Backbone RMSF during the trajectory
#		Side chain RMSF during the trajectory
#		Ligand RMSF during the trajectory
#		Backbone radius of gyration
#		Secondary structure changes
#		Clusterize trajectory and output central structures in each
#			cluster for the system and for the solute
#		TO BE ADDED: compute H-bonds between protein and ligands
#
# AUTHOR
#	JosÂ´e R. Valverde, CNB/CSIC. jrvalverde@cnb.csic.es, 2014
#
#	Licensed under (at your option) either GNU/GPL or EUPL
#
# LICENSE:
#
#	Copyright 2014 JOSE R VALVERDE, CNB/CSIC.
#	Copyright 2018 JOSE R VALVERDE, CNB/CSIC.
#
#	EUPL
#
#       Licensed under the EUPL, Version 1.1 or \u2013 as soon they
#       will be approved by the European Commission - subsequent
#       versions of the EUPL (the "Licence");
#       You may not use this work except in compliance with the
#       Licence.
#       You may obtain a copy of the Licence at:
#
#       http://ec.europa.eu/idabc/eupl
#
#       Unless required by applicable law or agreed to in
#       writing, software distributed under the Licence is
#       distributed on an "AS IS" basis,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
#       express or implied.
#       See the Licence for the specific language governing
#       permissions and limitations under the Licence.
#
#	GNU/GPL
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
set +x

. ~/contrib/gromacs-2025/bin/GMXRC.bash

LIB=`dirname ${BASH_SOURCE[0]}`/lib	# located within our same directory

source $LIB/include.bash

include util_funcs.bash
include fs_funcs.bash
include gmx_setup_cmds.bash
include gmx_fix_multichain_xvg.bash
include gmx_full_trr_to_xtc.bash
include gmx_xtc_last_time.bash
include gmx_trr_struct_at.bash
include gmx_xtc_struct_at.bash
include gmx_xtc_fit.bash
include gmx_xtc_fix_pbc.bash
include gmx_xtc_remove_solvent.bash
include gmx_xtc_analyze_covariance.bash
include gmx_xtc_analyze_chi.bash
include gmx_xtc_plot_evolution.bash
include gmx_xtc_compute_rmsd.bash
include gmx_xtc_compute_rmsf.bash
include gmx_xtc_compute_gyr_acf.bash
include gmx_xtc_compute_secondary_structure.bash
include gmx_xtc_cluster.bash
include gmx_xtc_compute_sas.bash
include gmx_gro2pdb.bash
include gmx_gro_to_pdb.bash
include gmx_make_ext_index.bash
include gmx_ndx_dedup.bash
include gmx_trj_assemble.bash
include gmx_trj_rmsd_vs_ref.bash
include gmx_trj_hbonds.bash
include gmx_trj_contacts.bash
include gmx_xvg_plot.bash
include gmx_xvg_stats.bash
include fgp_xvg_plot.bash

function gmx_xtc_analyze_ligands {
# THIS FUNCTION NEEDS CAREFUL REVIEW (*** JR ***)
    md="$1"
    ligands="$2"
    
    # count H-bonds (protein vs. ligands)
    #	Luckily, when the Complex is generated a group named 'Other'
    #	is generated that includes all non-protein elements (without solvent)
    #
    # $ligands is a file listing in each line one ligand with its charge
    if [ -s $ligands ] ; then
        echo ""
        echo ">>> Analyzing ligands and ligand interactions"
        echo ""

	#
        # ligand (non-protein) RMSD and RMSF
    	#
	if [ ! -e ${md}_nonprot_rmsd.xvg ] ; then
            $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsd.xvg -tu ns <<END
non-Protein
non-Protein
END
	    $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsd.SVG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	    $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsd.PNG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	fi
        if [ ! -e ${md}_nonprot_rmsf.xvg ] ; then
            echo "non-Protein"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsf.xvg -oq ${md}_nonprot_rmsf.pdb
            $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsf.SVG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
            $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsf.PNG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
	fi
        
        while read lig charge ; do
            # for each ligand
            if [ ! -e ${md}_${lig}_rmsd.xvg ] ; then
                $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsd.xvg -tu ns <<END
$lig
$lig
END
	        $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsd.SVG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	        $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsd.PNG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	    fi
            if [ ! -e ${md}_${lig}_rmsf.xvg ] ; then
                echo "$lig"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsf.xvg -oq ${md}_${lig}_rmsf.pdb
                $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsf.SVG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
                $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsf.PNG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
	    fi
        done <$ligands
        

	#
        # H-bonds between Protein and ligands
        #
        $g_hbond -f $md.xtc -s $md.tpr \
	        -num ${md}_hbnum.xvg -ac ${md}_hbac.xvg \
                <<END
Protein
Other
END
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbnum.SVG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbnum.PNG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbac.SVG ${md}_hbac.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbac.PNG ${md}_hbac.xvg -pexec 'runavg(S0,100)'

        # for each ligand
        #
        #	XXX JR XXX HACK HACK HACK HACK HACK HACK
        #
        #	WE HAVE A PROBLEM if Solvent has been used:
        #	gromacs duplicates the ligand groups, and so we cannot
        #	select them independently by name
        #
        #	On the other hand: the motivating behaviour is
        #	a known bug in Gromacs that has been assigned
        #	low priority because groups can still be selected
        #	by number.
        #
        #	use $md_complex.gro if it exists (implies solvent existed)
        #	  to make an index file without solvent interference
        #	else use $md.ndx instead (if there is no solvent there is no problem)
        #
        #	We could use the index of Complex_b4ion.pdb or Complex.pdb as a guide
        #	instead. This works because solvent is added AFTER the original 
        #	Complex and, so, the coordinate offsets in Complex.pdb are preserved.
        #	But that would imply using a hardcoded value and is a 'no-no'.
        #
        grep -q "^\[ SOL" $md.ndx
        if [ $? -eq 0 ] ; then
            echo "q" | $make_ndx -f ${md}_complex.pdb -o ${md}_complex.ndx
            ndx=${md}_complex.ndx
        else
            ndx=$md.ndx
        fi
        #
        while read lig charge ; do
            if [ ! -e ${md}_hb_${lig}_num.xvg ] ; then
                $g_hbond -f $md.xtc -s $md.tpr -n $ndx\
	                -num ${md}_hb_${lig}_num.xvg -ac ${md}_hb_${lig}_ac.xvg \
                        <<END
Protein
$lig
END
    	        $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_num.SVG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
    	        $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_num.PNG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_ac.SVG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_ac.PNG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
	    fi
        done < $ligands

	#
        # Solvent Accessible Surface Area and volume
        #
	
        # we need different commands for Protein and Protein+ligans
        if [ -s Ligands.pdb ] ; then
            # create an index of protein plus all ligands
            #	This works because group Other was created before addition
            #	of water and contains only the ligands with no solvent
            $make_ndx  -f ${md}.tpr -o pro+lig.ndx <<END
"Protein"|"Other"
q
END
            # use the extended group to compute an "extended" protein
            # surface area (protein + ligands)
            $g_sas -s ${md}.tpr -f ${md}.xtc -o ${md}_complex_sasa.xvg -tv ${md}_complex_vol.xvg \
    	        -n pro+lig.ndx <<END
Protein_Other
Protein_Other
END
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_sasa.SVG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_sasa.PNG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_vol.SVG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_vol.PNG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
	fi

    fi
}





function analyze_md_run {
    # arguments: MD run base name
    # requirements:
    #	$md.tpr		-- topology file
    #	$md.trr		-- original trajectory file
    #	$md.edr		-- energy evolution	
    #
    #	Complex_water.pdb if water was used in the simulation
    #
  if [ "USE_GETARGS" = "YES" ] ; then
    get_args "$@"
    local name="md"	# default
    if is_set n ; then name="$m"
    elif is_set name ; then :
    elif [ ${#extra_args[@]} -gt 0 ] ; then name="${extra_args[0]}" ; fi
    md="${name}"
    
    local ligfile="LIGANDS.ok"
    if is_set l ; then ligfile="$l"
    elif is_set ligands ; then :
    elif [ ${#extra_args[@]} -gt 1 ] ; then ligands="${extra_args[1]}" ; fi
    
    local interact=""		# e.g chA-chB,Protein-DNA,chA_chB-chC_chD	
    if is_set i ; then interact="$i"
    elif is set interact ; then :
    elif [ ${#extra_args[@]} -gt 2 ] ; then interact="${extra_args[2]}" ; fi
    group1=`echo "$interact" | cut -d- -f1`
    group2=`echo "$interact" | cut -d- -f2`
    
    local reference=""		# e.g. complex.pdb
    if is_set r ; then reference="$m"
    elif is_set reference ; then :
    elif [ ${#extra_args[@]} -gt 3 ] ; then reference="${extra_args[3]}" ; fi
    
    local match=""		# e.g. A=B,B=A (chain in ref with chain in trj)
    if is_set m ; then match="$m"
    elif is_set match ; then :
    elif [ ${#extra_args[@]} -gt 4 ] ; then match="${extra_args[4]}" ; fi
  fi  


    local dyn=${1:-md}
    local ligands=${2:-LIGANDS}
    local group1=${3:-Protein}	# e.g. Protein		groups to compute interactions
    local group2=${4:-DNA}	# e.g. DNA
    local aa=${5:-0}		# amino acid to analyze in detail (unused)
    
    local trj=""
    local md="${dyn%.*}"
    local ext="${dyn##*.}"      # we'll ignore any extension and only use md name

    echo ""
    boldblue "analyze_md_run: Analyzing MD run $md"
    boldblue "$0 $*"
    echo ""
    #
    # check validity of arguments
    #
    if [ ! -s "${md}".trr -a ! -s "${md}".xtc ] ; then
        # maybe it is split into sub-trajectories that we need to
	# assemble (named md_1 .. md_n using consecutive numbers)
        gmx_trj_assemble "${md}"
    fi
    
    # ensure we do actually have a trajectory
    if [ ! -s "${md}".trr -o ! -s "${md}".xtc ] ; then
    	boldred "analyze_md_run ERROR: No trajectory found for MD run \"$md\"."
        return 1
    elif [ -s "${md}.xtc" ] ; then 
        trj="$md.xtc"
    elif [ -s "$md.trr"]  ; then 
        trj="$md.trr"
    fi
    if [ ! -e "${md}.edr" -o ! -e "${md}".tpr ] ; then
	echo "ERROR: ${md}.edr FILE DOES NOT EXIST"
	echo "EXITING"
	return 1
    fi

    #
    # work on a subdirectory
    #
    boldblue "Output will be saved in ${md}_analysis"
    mkdir -p "${md}_analysis"
    cd "${md}_analysis"

    if [ -e DONE ] ; then
        boldblue "analyze_md_run: MD run \"${md}\" is already analyzed"
        boldblue "analyze_md_run: remove file ${md}_analysis_done to re-analyze"
        return 0
    fi

    # link all files we may need or use from the parent directory
    for i in ../"${md}".{trr,xtc,tpr,edr,gro,pdb,ndx,log,top,mdp} \
        ../"${reference}" ; do
        #cho "$i"
	if [ ! -s "$i" ] ; then continue ; fi
        symlink "$i" `basename "$i"`
    done
    #
    # THERE WE GO!
    #
    # add definitions of solute, solvent and chains
    if [ ! -e "$md".ndx ] ; then
        boldblue "Building extended index"
        gmx_make_ext_index "${md}.pdb"
    fi
    
    boldblue "Creating XTC file"
    if [ ! -e "${md}.xtc" ] ; then
        # we must have a .trr file (or we wouldn't be here)
	#    --there is no XTC, so there must be a TRR--
	# convert to XTC and save last time as $md.lastt
	gmx_trr_to_xtc "$md"
    fi
    
    # get first last configuration (if not present)
    boldblue "Saving first and last conformations"
    # save last time registered in the trajectory
    if [ ! -e "${md}.lastt" ] ; then
        # save trajectory last time to $md.lastt
        gmx_xtc_last_time "$md"
    fi
    # get last time in the trajectory
    lastt=`cat "$md.lastt"`

    # get first configuration if not present
    if [ ! -e ${md}_init.gro ] ; then
        gmx_trr_struct_at "$md" "0"
        ln "$md".tpr "$md"_init.tpr        # so we can preserve chain info
        if [ ! -e "$md.0.gro" ] ; then ln "${md}_init.gro" "${md}.0.gro" ; fi
        gmx_gro2pdb "${md}_init.gro" System mol
        if [ ! -e "$md.0.pdb" ] ; then ln "${md}_init.pdb" "${md}.0.pdb" ; fi
    fi

    # usually GROMACS saves the last conformation as $md.{gro,pdb}
    # since it is costly to retrieve it (needs reading the whole,
    # potentially large, trajectory), if present, we'll use it.
    if [ -s "${md}".gro -a ! -e "${md}_last.gro" ] ; then 
        ln "${md}.gro" "${md}_last.gro" ; 
    fi
    if [ ! -s ${md}_last.gro ] ; then
	gmx_trr_struct_at "$md" "-1"            # -1 means last frame/time
        ln "$md".tpr "$md"_last.tpr             # for pdb conversion later
	if [ ! -e "$md.gro" ] ; then ln "${md}_last.gro" "${md}.gro" ; fi
    fi
    if [ -s "${md}".pdb -a ! -e "${md}_last.pdb" ] ; then 
        ln "${md}.gro" "${md}_last.pdb" ; 
    fi
    if [ ! -s ${md}_last.pdb ] ; then
	gmx_gro2pdb "${md}_last.gro"
	if [ ! -s "$md.pdb" ] ; then ln "${md}_last.pdb" "${md}.pdb" ; fi
    fi
    

    boldblue "Analyzing molecular dynamics evolution"
    gmx_xtc_plot_evolution "$md"
    
    
    boldblue "Fitting system to itself"
    # fit trajectory using first frame as reference
    # and save as ${md}_fit.xtc
    if [ ! -e ${md}_fit.xtc ] ; then
	    gmx_xtc_fit "$md"
    fi

    boldblue "Fixing fitted trajectory for PBC conditions"
    # correct trajectory for PBC if needed, centering 
    # the system around the protein, and generating 
    # ${md}_PBC.xtc and ${md}_PBC.tpr files,
    # as well as a sparse version of 1 each 10th frame
    # ${md}_PBC_sparse.xtc and ${md}_PBC_sparse.tpr
    if [ ! -e ${md}_fit_PBC.xtc ] ; then
        gmx_xtc_fix_pbc "${md}_fit"
    fi
    symlink "${md}_fit_PBC.xtc" "${md}_PBC.xtc"
    symlink "${md}_fit_PBC.tpr" "${md}_PBC.tpr"
    symlink "${md}_fit_PBC.top" "${md}_PBC.top"
    symlink "${md}_fit_PBC.ndx" "${md}_PBC.ndx"
    
    
    boldblue "Extracting complex (removing solvent)"
    # Remove solvent from ${md}_PBC 
    # and save first and last configurations of the solvent-free complex
    # This will save a "${md}_PBC_complex.xtc" trajectory
    if [ ! -e "${md}_complex.xtc" ] ; then
	    gmx_xtc_remove_solvent "${md}_PBC"
	    gmx_ndx_dedup "${md}_PBC"		# just in case
    fi
    symlink "${md}_PBC_complex.xtc" "${md}_complex.xtc"
    symlink "${md}_PBC_complex.top" "${md}_complex.top"
    symlink "${md}_PBC_complex.tpr" "${md}_complex.tpr"
    symlink "${md}_PBC_complex.ndx" "${md}_complex.ndx"
 
#    boldblue "Fitting complex to itself"
#    if [ ! -e ${md}_complex_fit.xtc ] ; then
#        gmx_xtc_fit "${md}_complex"
#    fi
    
    
    boldblue "Analyzing covariance"
    gmx_xtc_analyze_covariance "${md}_complex"
    #gmx analyze -comp -rmsf -eig -proj -2d -3d -extr
    
    
    boldblue "Analyzing ring flips"
    # check for ring flips (e.g. Phe/Tyr)
    gmx_xtc_analyze_chi "${md}_complex"  
    
    
    # Compute structural changes
    #	1. RMSD (movement w.r.t. original conformation)
    #	Show structural stability using ns as time unit
    boldblue "Computing RMSD"
    gmx_xtc_compute_rmsd "${md}_complex"

    #	2. RMSF (movility per atom/residue)
    boldblue "Computing RMSF"    
    gmx_xtc_compute_rmsf "${md}_complex"
    
    if [ "$reference" != "" ] ; then
        boldblue "Computing rmsd against $reference $chainmatch"
        gmx_trj_rmsd_vs_ref "$reference" "${md}_complex.xtc" "$match"
        cd ..
    fi

    #	3. Radius of gyration (compactness and stability of the structure)
    #	backbone
    # The radius of gyration of a protein is a measure of its compactness. 
    # If a protein is stably folded, it will likely maintain a relatively 
    # steady value of R_g. 
    # If a protein unfolds, its R_g will change over time. 
    boldblue "Computing radius of gyration autocorrelation $md"
    gmx_xtc_compute_gyr_acf "${md}_complex"
    
    #	4. Compute secondary structure changes
    boldblue "Computing secondary structure"
    gmx_xtc_compute_secondary_structure "${md}_complex"

    #	5. Clusterize trajectory and output central structures in
    #	each cluster.
    #g_cluster -s md_complex.tpr -f md_complex.trr -dist rmsd-distribution.xvg \
    #	-o clusters.xpm -sz cluster-sizes.xvg -tr cluster-transitions.xpm \
    #        -ntr cluster-transitions.xvg -clid cluster-id-over-time.xvg \
    #        -cl clusters.pdb -cutoff 0.25 -method gromos -dt 10 [ -av ]
    boldblue "Clustering conformations"
    gmx_xtc_cluster "${md}_complex"
    
    
    # protein surface area
    boldblue "Computing Solvent Accessible Surface area"
    gmx_xtc_compute_sas "${md}_complex"
    
    
    # Compute interactions between the specified groups
    # first add the groups to the ndx file if they do not exist
    if ! grep -q "$group1" "$md.ndx" ; then
        gmx_make_ext_index "$md.pdb" \
	< <( echo -e "$group1\nq" ) 
    fi
    if ! grep -q "$group2" "$md.ndx" ; then
        gmx_make_ext_index "$md.pdb" \
	< <( echo -e "$group2\nq" ) 
    fi
    
    #   1. H-Bonds
    boldblue "Computing H-bonds between $group1 and $group2"
    gmx_trj_hbonds "$md" "$group1" "$group2"

    #   2. Contacts
    boldblue "Computing contacts between $group1 and $group2"
    gmx_trj_contacts "$md" "$group1" "$group2" 
    
    #   3. Can we calculate electrostatics/VdW?
    # we need to create a new mdp file from the md.mdp,
    # as well as a new tpr from it using grompp, and then
    # run mdrun on CPU (not GPU) to get the energies, and
    # finaly gmx energy to get them.
    # See http://www.mdtutorials.com/gmx/complex/09_analysis.html
    
    
    # repeat interaction calculations for a specific a.a.
    # define group and analyze it
    
    
    boldblue "Computing averages"
    mkdir -p averages
    if [ ! -s "averages/${md}_average.txt" ] ; then
    cat "$md.log" \
	| sed -ne '/<======  ###############  ==>/,/M E /p' \
	| head -n -1 \
        > "averages/${md}_average.txt"
    fi
    if [ ! -s "averages/${md}_avg_pressure.txt" ] ; then
    cat "$md.log" \
	| sed -n '/^ Pressure /{n;p;}' \
	| cut -c 1-15 \
	| tail -n 1 \
        > "averages/${md}_avg_pressure.txt"
    fi
    if [ ! -s "averages/${md}_avg_tot_energy.txt" ] ; then
    cat "$md.log" \
	| sed -ne '/<======  ###############  ==>/,/M E /p' \
        | sed -n '/   Total Energy  /{n;p;}' \
        | cut -c 16-30 \
        > "averages/${md}_avg_tot_energy.txt"
    fi
    if [ ! -s "averages/${md}_avg_temperature.txt" ] ; then
    cat "$md.log" \
	| sed -ne '/<======  ###############  ==>/,/M E /p' \
	| sed -n '/    Temperature /{n;p;}' \
	| cut -c 46-60 \
	> "averages/${md}_avg_temperature.txt"
    fi
    if [ ! -s "averages/${md}_avg_coulomb_sr.txt" ] ; then
    cat "$md.log" \
	| sed -ne '/<======  ###############  ==>/,/M E /p' \
	| sed -n '/   Coulomb /{n;p;}' \
	| cut -c 31-45 \
	> "averages/${md}_avg_coulomb_sr.txt"
    fi
    
        
    # for all ligands
#    gmx_xtc_analyze_ligands "$md" "$ligands"


    boldblue "computing statistics"
    for x in *.xvg */*.xvg ; do 
        if [ ! -e $x ] ; then continue ; fi
	    gmx_xvg_stats $x
    done


    boldblue "Doing any pending tasks"
    # Last resort to ensure all XVG files are plotted
    for x in *.xvg */*.xvg ; do 
        if [ ! -e $x ] ; then continue ; fi
        if [ ! -s ${x%xvg}png ] ; then fgp_xvg_plot $x ; fi
    done
    for i in *.gro ; do
        if [ ! -e $i ] ; then continue ; fi
        if [ ! -s ${i%gro}pdb ] ; then gmx_gro_to_pdb "${i%.gro}" ; fi
    done

    touch DONE

    boldblue "DONE"
}


if [ "$LIBRARY"="no" ] ; then
    if [ $# -eq 0 ] ; then
	echo "Usage: "`basename $0`" trajectory [ligands]"
	exit
    elif [ $# -eq 1 ] ; then
        # should we strip the last part after a hypothetical dot just in case?
        trajectory="$1"
        ligands=''
    else
        trajectory="$1"
	ligands="$2"
    fi
    
    LIBRARY="yes"
    BASE=~/work/bin
    #BASE=~/work/lenjuanes/script
    #BASE=`dirname $0`

    cp $0 .
    analyze_md_run $* |& tee md_analysis.log
fi
