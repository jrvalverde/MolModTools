#!/bin/bash
#
# NAME
#	analyze_md_run -- analyze a completed MD run
#
# SYNOPSIS
#	analyze_md_run simulation
#
# DESCRIPTION	
#	simulation is the base name used to create all of a run output
#	files.
#
#	analyze_md_run will look for all the files generated by an MD
#	simulation and try to run a large battery of analysis tests on
#	them.
#
#	The tests include:
#		Generation of auxiliary indexes
#		Generation of auxiliary trajectories for solute alone
#		Fitting the system to itself
#		Graph of potential energy evolution
#		Graph of kinetic energy evolution
#		Graph of total energy evolution
#		Graph of pressure evolution
#		Graph of temperature evolution
#		Backbone RMSD with respect to original conformation
#		Ligand RMSD with respect to original conformation
#		Backbone RMSF during the trajectory
#		Side chain RMSF during the trajectory
#		Ligand RMSF during the trajectory
#		Backbone radius of gyration
#		Secondary structure changes
#		Clusterize trajectory and output central structures in each
#			cluster for the system and for the solute
#		TO BE ADDED: compute H-bonds between protein and ligands
#
# AUTHOR
#	Jos´e R. Valverde, CNB/CSIC. jrvalverde@cnb.csic.es, 2014
#
#	Licensed under (at your option) either GNU/GPL or EUPL
#
# LICENSE:
#
#	Copyright 2014 JOSE R VALVERDE, CNB/CSIC.
#	Copyright 2018 JOSE R VALVERDE, CNB/CSIC.
#
#	EUPL
#
#       Licensed under the EUPL, Version 1.1 or \u2013 as soon they
#       will be approved by the European Commission - subsequent
#       versions of the EUPL (the "Licence");
#       You may not use this work except in compliance with the
#       Licence.
#       You may obtain a copy of the Licence at:
#
#       http://ec.europa.eu/idabc/eupl
#
#       Unless required by applicable law or agreed to in
#       writing, software distributed under the Licence is
#       distributed on an "AS IS" basis,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
#       express or implied.
#       See the Licence for the specific language governing
#       permissions and limitations under the Licence.
#
#	GNU/GPL
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
cp $0 .

trjcat='gmx trjcat'

bold=`tput bold`
plain=`tput sgr0`
black=`tput setaf 0`
red=`tput setaf 1`
green=`tput setaf 2`
yellow=`tput setaf 3`
blue=`tput setaf 4`
magenta=`tput setaf 5`
cyan=`tput setaf 6`
lightgray=`tput setaf 7`

alias bold=`tput bold`
alias plain=`tput sgr0`
alias black=`tput setaf 0`
alias red=`tput setaf 1`
alias green=`tput setaf 2`
alias yellow=`tput setaf 3`
alias blue=`tput setaf 4`
alias magenta=`tput setaf 5`
alias cyan=`tput setaf 6`
alias lightgray=`tput setaf 7`

function boldblue {
    echo -n "$bold$(tput setaf 4) "
    echo -n "$*"
    echo "$(tput setaf 0)$plain"
}

function boldred {
    echo -n "$bold$(tput setaf 1)"
    echo -n "$*"
    echo "$(tput setaf 0)$plain"
}



function fixMcXvg() {
    # multichain XVG files have all chains one after another with no
    # separation which makes the plots join the end of one to the 
    # start of the next.
	#
    # This can be fixed detecting backward jumps in numeration and
    # inserting an '&' which means 'start a new plot in a new color'
	#
	# However, this may create a problem for very large (>99 999 atoms)
	# systems, because in this case numbers wrap-around and restart
	# from 0.
	#
	# We can exploit this 'feature' to our advantage detecting if the
	# wrap-around number is '0' or if the last atom seen was 99·999
        # and not changing color then.

    name=${1%.xvg}

    lastx="-99999"
    cat $name.xvg \
    | while read l ; do 
	if [[ ${l::1} == [\#@\&] ]] ; then
            echo "$l" 
	else
            read x y <<< "$l"
	    #if [ $x -lt $lastx ] ; then
	    if [ $x -ne $((lastx+1)) ] ; then
	        if [ "$lastx" -ne 99999 -a "$x" -eq 0 ] ; then
		    echo "&"
                fi
	    fi
	    echo "$x	$y	$lastx"
	    lastx=$x
	fi

    done > $name.mc.xvg

}



# convert TRR to XTC file AND save last time in trajectory
function trr_to_xtc {
     md="$1"
	if [ ! -e "${md}.trr" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi
	if [ ! -e "${md}.ndx" ] ; then 
	    echo q | $make_ndx  -f "${md}.tpr" -o "${md}.ndx" ; 
	fi
	if [ ! -e "${md}.xtc" ] ; then
        boldblue "Creating XTC file"
        # create a smaller low-res trajectory file
        echo "System" | $trjconv -f "$md.trr" \
		    -o "$md.xtc" \
			-s "$md.tpr" \
			-n "$md.ndx" \
		    -pbc mol 2>&1 \
			| tee "${md}.toxtc.log"
        # AND get last time in trajectory
        cat "${md}.toxtc.log" \
               | grep "Reading frame" \
               | tail -n 1 | sed -e 's/.* time //g' >  "${md}.lastt"
    	# clean up
		rm "${md}.toxtc.log"
		return 0
    fi
}



function xtc_last_time {
    md="$1"
	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
    boldblue "Finding last time in trajectory"
    # find out last time in the trajectory from stderr of gmx check
    #lastt=`$g_check -f $md.xtc |& grep "Last frame" \
    #       | sed -e 's/.* time//g'`
    lastt=`$g_check -f $md.xtc |& grep "Reading frame" \
           | tail -n 1 | sed -e 's/.* time//g'`

    if [ "$lastt" == "" ] ; then 
        boldred "NO LAST FRAME!" 
        return 0; 
    fi
    echo "LAST TIME =" $lastt 
    echo $lastt > "${md}.lastt"
}


function trr_struct_at_t {
    md="$1"
	t="$2"
    tn="$t"			# save so we later know if we were asked for last
	
	if [ ! -e "${md}.trr" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi
	if [ ! -e "${md}.ndx" ] ; then 
	    echo q | $make_ndx  -f "${md}.tpr" -o "${md}.ndx" ; 
	fi
	if [ "$t" = "-1" ] ; then
	    if [ -e "$md.lastt" ] ; then
	        t=`cat "$md.lastt"`
			t=${t%% *}		# remove trailing space
        else
		    # get last time recorded in the trajectory
		    t=`$g_check -f "$md.trr" |& grep "Reading frame" \
               | tail -n 1 | sed -e 's/.* time//g'`
		fi
	fi
	if [ "$t" = "" ] ; then t=0 ; fi
	
	# do the extraction
    boldblue " Getting t=$t configuration from $md.trr"
    echo "System" | $trjconv -f "$md.trr" -s "$md.tpr" -n "$md.ndx" \
        	-o "${md}_${t}.gro" -dump $t
			
	if [ "${tn}" =  "0" ] ; then ln "${md}_${t}.gro" "${md}_init.gro" ; fi
	if [ "${tn}" = "-1" ] ; then ln "${md}_${t}.gro" "${md}_last.gro" ; fi
    return 0
}



function xtc_struct_at_t {
    md="$1"
	t="$2"
	tn="$t"
	
	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi
	if [ ! -e "${md}.ndx" ] ; then 
	    echo q | $make_ndx  -f "${md}.tpr" -o "${md}.ndx" ; 
	fi
	if [ "$t" = "-1" ] ; then
	    # use last saved time
		# try to avoid long calculations
	    if [ -e "$md.lastt" ] ; then
	        t=`cat "$md.lastt"`
        else
		    # get last time recorded in the trajectory
		    t=`$g_check -f "$md.xtc" |& grep "Reading frame" \
               | tail -n 1 | sed -e 's/.* time//g'`
			t=${t%% *}		# to remove any trailing white space
		fi
	fi
	if [ "$t" = "" ] ; then t=0 ; fi
	
	# do the extraction
    boldblue " Getting t=$t configuration from $md.xtc"
    echo "System" | $trjconv -f "$md.xtc" -s "$md.tpr" -n "$md.ndx" \
        	-o "${md}_${t}.gro" -dump $t -pbc nojump
	
    echo "1" | $trjconv -f "$md.xtc" -s "$md.tpr" -n "$md.ndx" \
        	-o "${md}_${t}_Protein.gro" -dump $t -pbc nojump
	
	if [ "${tn}" =  "0" ] ; then ln "${md}_${t}.gro" "${md}_init.gro" ; fi
	if [ "${tn}" = "-1" ] ; then ln "${md}_${t}.gro" "${md}_last.gro" ; fi
	return 0
}



function xtc_fit {
    md="$1"
	if [ ! -e "$md.xtc" ] ; then return 1 ; fi
	if [ ! -e "$md.tpr" ] ; then return 2 ; fi
	if [ ! -e "$md.ndx" ] ; then return 3 ; fi
	boldblue "Fitting trajectory $md.xtc"
	if [ ! -e "${md}_fit.xtc" -o ! -e "${md}_fit.tpr" ] ; then
        $trjconv -f $md.xtc -s $md.tpr -n $md.ndx \
		    -o ${md}_fit.xtc -fit rot+trans <<END
System
System
END
	    cp $md.tpr ${md}_fit.tpr
    fi
	return 0
}



function xtc_fix_pbc {
    md="$1"
	if [ ! -e "$md.xtc" ] ; then return 1 ; fi
	if [ ! -e "$md.tpr" ] ; then return 2 ; fi
    boldblue "Correcting trajectory $md.xtc for PBC"
    if [ ! -e ${md}_noPBC.xtc ] ; then
        echo -e "\nSystem\n\n" | $trjconv -s $md.tpr -f $md.xtc \
        		-o ${md}_noPBC.xtc -pbc mol -ur compact
        cp $md.tpr ${md}_noPBC.tpr
    fi
	
	# make second version with no jumps
    if [ ! -e ${md}_nojump.xtc ] ; then
        echo "System" | $trjconv -s $md.tpr -f $md.xtc \
        		-o ${md}_nojump.xtc -pbc nojump -ur compact
        cp $md.tpr ${md}_nojump.tpr
    fi

    # make sparse trajectory for quick visualization
    if [ ! -e ${md}_noPBC_sparse.xtc ] ; then
        echo "System" | $trjcat -f ${md}_noPBC.xtc -o ${md}_noPBC_sparse.xtc \
	    -dt 10
        cp $md.tpr ${md}_noPBC_sparse.tpr
    fi
	return 0
}



function xtc_remove_solvent {
    md="$1"
	
	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	# if there is a version with PBC, prefer it
	if [ -e "${md}_noPBC.xtc" ] ; then 
	    trj="${md}_noPBC" 
	elif [ -e "${md}_nojump.xtc" ] ; then
	    trj="${md}_nojump"
	else
	    trj="${md}"
	fi
	if [ ! -e "${trj}.tpr" ] ; then return 2 ; fi
	if [ ! -e "${trj}.ndx" ] ; then 
	    echo q | $make_ndx  -f "${trj}.tpr" -o "${trj}.ndx" ; 
	fi

	if [ ! -e "${md}_complex.xtc" ] ; then
    	# Remove solvent
    	boldblue "Removing solvent"
    	if grep -q "^(\[ Solute \]" "$md.ndx" ; then
		# first check if there is a Solute group
		    selection="Solute"
		elif grep -q "^(\[ Solvent \]" "$md.ndx" ; then
    	# if there is no solute defined, check if there is a SOLVENT group
		    selection="!Solvent"
    	elif grep -q "^(\[ SOL_ION \]" "$md.ndx" ; then
		# or maybe it was a protein with complexed ions
 			selection="SOL_ION"
    	elif grep -q "^(\[ Water_and_ions \]" "$md.ndx" ; then
		# if neither solute nor solvent exist, try water+ions
		    selection="!Water_and_ions"
    	elif grep -q "^(\[ Water \]" "$md.ndx" ; then
		# maybe there is only water and no ions
		    selection="!Water"
		else
		    selection="System"
		fi
		if [ "$selection" != "System" ] ; then
			if [ ! -e "${md}_complex.xtc" ] ; then
		    	# create trajectory without solvent
            	echo "$selection" | $trjconv -f "${trj}.xtc" -s "$trj.tpr" \
				    -n "$trj.ndx" \
        			-o "${md}_complex.xtc"
			fi
        	# create topology TPR file without solvent
			if [ ! -e "${md}_complex.tpr" ] ; then
            	echo "$selection" | $tpbconv -s "$trj.tpr"\
        			-n "$trj.ndx" \
				    -o "${md}_complex.tpr"
			fi
¡    	else
	    	# likely a simulation in vacuo, no need to waste space
        	#ln -s $md.xtc ${md}_complex.xtc
        	# prefer to work without PBC
        	ln "$trj.xtc" "${md}_complex.xtc"
        	ln "$trj.tpr" "${md}_complex.tpr"
    	fi
    fi
	
	# save initial and last configurations
	if [ ! -e "${md}_complex_init.gro" ] ; then
    	# dump initial (first, number 0) frame from the trajectory
		xtc_struct_at_t  "${md}_complex" 0
    fi
	if [ ! -e "${md}_complex_last.gro" ] ; then
    	# dump last frame from the trajectory
		xtc_struct_at_t "${md}_complex" -1
    fi
    return 0
}



function xtc_analyze_covariance {
    md="$1"

	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	# if there is a non-solvent version, prefer it
	if [ -e "${md}_complex.xtc" ] ; then 
	    trj="${md}_complex" 
	else
	    trj="${md}"
	fi
	if [ ! -e "${trj}.tpr" ] ; then return 2 ; fi
	if [ ! -e "${trj}.ndx" ] ; then 
	    $make_ndx  -f "${trj}.tpr" -o "${trj}.ndx" <<< <(echo 'q') ; 
	fi

    boldblue "Covariance analysis"
    mkdir -p "${md}_covariance"
	cd "${md}_covariance"
	ln -s "../$trj.xtc" .
	ln -s "../$trj.tpr" .
	ln -s "../$trj.ndx" .
    if [ ! -s "${md}_eigenvec.trr" ] ; then
        # we should choose a representative reference structure, e.g. a cluster
	    gmx covar -s "$trj.tpr" -f "$trj.xtc" -n "$trj.ndx" \
        	-xpm  "${md}_covar.xpm" \
			-xpma "${md}_covar_aa.xpm" \
	    	-o    "${md}_eigenval.xvg" \
			-av   "${md}_covar_average.pdb" \
	    	-v    "${md}_eigenvec.trr" \
	    	<<END
Backbone
Backbone
END
    fi
    cd ..
	return 0
}



function xtc_check_ring_flips {
    md="$1"

	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	# if there is a non-solvent version, prefer it
	if [ -e "${md}_complex.xtc" ] ; then 
	    trj="${md}_complex" 
	else
	    trj="${md}"
	fi
	if [ ! -e "${trj}.tpr" ] ; then return 2 ; fi
	if [ ! -e "${trj}.ndx" ] ; then 
	    $make_ndx  -f "${trj}.tpr" -o "${trj}.ndx" <<< <(echo 'q') ; 
	fi

    mkdir "${md}_chi"
	cd "${md}_chi"
	ln -s "../$trj.xtc" .
	ln -s "../$trj.tpr" .
    # check for ring flips (e.g. Phe/Tyr)
    gmx chi -s ${trj}.tpr -f ${trj}.xtc -all -maxchi 2
	cd ..
	return 0
}



function xtc_plot_evolution {
    md="$1"
	
	if [ ! -e "$md.edr" ] ; then return 1 ; fi

    boldblue "Plotting system evolution"
    if [ ! -e "${md}_plots/${md}_potenergy.xvg" ] ; then
        echo "Potential"    | $g_energy -f $md.edr -o ${md}_potenergy.xvg
    fi
    if [ ! -e "${md}_plots/${md}_kinenergy.xvg" ] ; then
       echo "Kinetic-En"   | $g_energy -f $md.edr -o ${md}_kinenergy.xvg
    fi
    if [ ! -e "${md}_plots/${md}_totenergy.xvg" ] ; then
        echo "Total-Energy" | $g_energy -f $md.edr -o ${md}_totenergy.xvg
    fi
    if [ ! -e "${md}_plots/${md}_pressure.xvg" ] ; then
        echo "Pressure"     | $g_energy -f $md.edr -o ${md}_pressure.xvg
    fi
    if [ ! -e "${md}_plots/${md}_temperature.xvg" ] ; then
        echo "Temperature"  | $g_energy -f $md.edr -o ${md}_temperature.xvg
        #echo "20" | g_energy -f $md.edr -o ${md}_volume.xvg
        #echo "21" | g_energy -f $md.edr -o ${md}_density.xvg
    fi
    # Make plots with running average
    for i in SVG PNG ; do
        $grace -hardcopy -hdevice $i -printfile ${md}_potenergy.$i   ${md}_potenergy.xvg   -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_kinenergy.$i   ${md}_kinenergy.xvg   -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_totenergy.$i   ${md}_totenergy.xvg   -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_pressure.$i    ${md}_pressure.xvg    -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_temperature.$i ${md}_temperature.xvg -pexec 'runavg(S0,100)'
    done
	
	# and now, move everything to its final destination
	mkdir "{md}_plots"
	mv "${md}_"*"energy."*   "${md}_plots"
	mv "${md}_pressure."*    "${md}_plots"
	mv "${md}_tempreature."* "${md}_plots"
	
	return 0
}



function xtc_compute_rmsd {
    md="$1"
	
	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi
	
    boldblue "Computing RMSD from '$md'"
    if [ ! -e "${md}_rmsd/${md}_rmsd.xvg" ] ; then
        $g_rms -s ${md}.tpr -f ${md}.xtc \
		       -o ${md}_rmsd.xvg -tu ns <<END
Backbone
Backbone
END
        # and make a graph with running averages (100 data points)
        $grace -hardcopy -hdevice SVG -printfile ${md}_rmsd.SVG \
		       ${md}_rmsd.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_rmsd.PNG \
		       ${md}_rmsd.xvg -pexec 'runavg(S0,100)'
    fi
	# move output into a subdirectory
	mkdir "${md}_rmsd"
	mv *_rmsd.* "${md}_rmsd"
	
	return 0
}



function xtc_compute_rmsf {
    md="$1"
	
	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi
	
    boldblue "Computing RMSF from '$md'"
	
    #	backbone
    if [ ! -e "${md}_rmsf/${md}_complex_rmsf_bb.xvg" ] ; then
    	boldblue "    backbone"
        echo "Backbone"  | $g_rmsf -s ${md}.tpr -f ${md}.xtc \
		    -o ${md}_rmsf_bb.xvg -oq ${md}_rmsf_bb.pdb -res

        $grace -hardcopy -hdevice SVG -printfile ${md}_rmsf_bb.SVG ${md}_rmsf_bb.xvg -pexec 'runavg(S0,100)' 
        $grace -hardcopy -hdevice PNG -printfile ${md}_rmsf_bb.PNG ${md}_rmsf_bb.xvg -pexec 'runavg(S0,100)' 
    fi
    if [ ! -e "${md}_rmsf/${md}_rmsf_bb.mc.xvg" ] ; then
    	boldblue "    backbone (multichain)"
	    # attempt to fix multichain plots
	    fixMcXvg ${md}_rmsf_bb.xvg
        $grace -hardcopy -hdevice SVG -printfile ${md}_rmsf_bb.mc.SVG ${md}_rmsf_bb.mc.xvg -pexec 'runavg(S0,100)' 
        $grace -hardcopy -hdevice PNG -printfile ${md}_rmsf_bb.mc.PNG ${md}_rmsf_bb.mc.xvg -pexec 'runavg(S0,100)' 
    fi    
    #	side chains
    if [ ! -e "${md}_rmsf/${md}_rmsf_sc.xvg" ] ; then
    	boldblue "    sidechains"
        echo "SideChain" | $g_rmsf -s ${md}.tpr -f ${md}.xtc -o ${md}_rmsf_sc.xvg -oq ${md}_rmsf_sc.pdb

        $grace -hardcopy -hdevice SVG -printfile ${md}_rmsf_sc.SVG ${md}_rmsf_sc.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_rmsf_sc.PNG ${md}_rmsf_sc.xvg -pexec 'runavg(S0,100)'
    fi
    #	non-protein (ligands)
    if [ -s Ligands.pdb ] ; then
    	boldblue "    ligands"
        echo "non-Protein" | $g_rmsf -s ${md}.tpr -f ${md}.xtc -o ${md}_rmsf_np.xvg -oq ${md}_rmsf_np.pdb
        $grace -hardcopy -hdevice SVG -printfile ${md}_np_rmsf.SVG ${md}_np_rmsf.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_np_rmsf.PNG ${md}_np_rmsf.xvg -pexec 'runavg(S0,100)'
    fi
	
	mkdir "${md}_rmsf"
	mv *_rmsf*.* "${md}_rmsf"
	return 0
}



function xtc_compute_gyr_acf {
    md="$1"
	
	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi

    boldblue "Computing radius of gyration"
    # ACF is the autocorrelation function.
    #
    if [ ! -e "${md}_gyr/${md}_gyr.xvg" ] ; then
        echo "Backbone" | $g_gyrate -s ${md}.tpr \
                      -f ${md}.xtc -o ${md}_gyr.xvg \
		      -acf ${md}_acf.xvg
        $grace -hardcopy -hdevice SVG -printfile ${md}_gyr.SVG ${md}_gyr.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_gyr.PNG ${md}_gyr.xvg -pexec 'runavg(S0,100)'
    fi
	mkdir "${md}_gyr"
	mv "${md}_gyr."* "${md}_gyr"
	mv "${md}_acf."* "${md}_gyr"
	return 0
 }


function xtc_compute_secondary_structure {
    md="$1"
	
	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi

    boldblue "Computing secondary structure changes"
    if [ ! -e "${md}_ss/${md}_ss.xpm" ] ; then
    # this doesn't work on SARS for some reason
        echo "compute secondary structure"
        $do_dssp -f ${md}.xtc -s ${md}.tpr -sc ${md}_scount.xvg -o ${md}_ss.xpm -dt 10 <<END
MainChain
END

        $grace -nxy ${md}_scount.xvg -hardcopy -hdevice SVG -printfile ${md}_scount.SVG
        $grace -nxy ${md}_scount.xvg -hardcopy -hdevice PNG -printfile ${md}_scount.PNG

        cat > ps.m2p <<END
; Matrix options
titlefont       = Helvetica     ; Matrix title Postscript Font name
titlefontsize   = 20.0          ; Matrix title Font size (pt)
legend          = yes           ; Show the legend
legendfont      = Helvetica     ; Legend name Postscript Font name
legendfontsize  = 12.0          ; Legend name Font size (pt)
legendlabel                     ; Used when there is none in the .xpm
legend2label                    ; Id. when merging two xpm s
xbox            = 20.0           ; x-size of a matrix element
ybox            = 2.0          ; y-size of a matrix element
matrixspacing   = 20.0          ; Space between 2 matrices
xoffset         = 0.0           ; Between matrix and bounding box
yoffset         = 0.0           ; Between matrix and bounding box

; X-axis options
x-lineat0value  = no            ; Draw line at matrix value==0
x-major         = 100.0        ; Major tick spacing
x-minor         = 50.0         ; Id. Minor ticks
x-firstmajor    = 0.0           ; Offset for major tick
x-majorat0      = no            ; Additional Major tick at first frame
x-majorticklen  = 8.0           ; Length of major ticks
x-minorticklen  = 4.0           ; Id. Minor ticks
x-label         =               ; Used when there is none in the .xpm
x-font          = Helvetica     ; Axis label PostScript Font
x-fontsize      = 12            ; Axis label Font size (pt)
x-tickfont      = Helvetica     ; Tick label PostScript Font
x-tickfontsize  = 8             ; Tick label Font size (pt)

;Y-axis options
y-lineat0value  = none
y-major         = 10.0
y-minor         = 5.0
y-firstmajor    = 0.0
y-majorat0      = no
y-majorticklen  = 8.0
y-minorticklen  = 4.0
y-label         =
y-fontsize      = 12
y-font          = Helvetica
y-tickfontsize  = 8
y-tickfont      = Helvetica
END

        $xpm2ps -f ${md}_ss.xpm -di ps.m2p -o ${md}_ubq_ss.eps
    fi

    mkdir "${md}_ss"
	mv "${md}_scount."* "${md}_ss"
	mv "${md}_ss."* "${md}_ss"
    return 0
}



function xtc_cluster {
    md="$1"

	if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
	if [ ! -e "${md}.tpr" ] ; then return 2 ; fi

    boldblue "Clustering"
    if [ ! -e "${md}_cluster/${md}_clusters.pdb" ] ; then
        $g_cluster -s $md.tpr -f ${md}.xtc \
		    -cl ${md}_clusters.pdb -cutoff 0.5 \
	        -method gromos -dt 10 -dist ${md}_rmsd-dist.xvf \
			-o ${md}_rmsd-clust.xpm <<END
Protein
System
END
        mv "${md}"*clust*.* ${md}_rmsd-dist.xvf  "${md}_cluster"
    fi
    # and now get the cluster average structures
    if [ ! -e "${md}_cluster/${md}_av_clust.pdb" ] ; then
        $g_cluster -s $md.tpr -f $md.xtc \
		    -cl ${md}_av_clust.pdb -cutoff 0.5 \
	        -method gromos -dt 10 -av -dist ${md}_av_rmsd-dist.xvf \
			-o ${md}_av_rmsd-clust.xpm <<END
Protein
System
END
        mv "${md}_av_"* "${md}_cluster"
    fi

    #grep -q "^\[ SOL \]" $md.ndx
    #if [ $? -eq 0 ] ; then
    if egrep -q "^\[ SOL" $md.ndx ; then
	    if [ ! -e "${md}_cluster/${md}_complex_clusters.pdb" ] ; then
            # and now repeat for the complex alone
            #$g_cluster -s ${md}_complex.tpr -f ${md}_complex.trr -cl ${md}_complex_clusters.pdb -cutoff 0.5 \
	    	$g_cluster -s ${md}_complex.tpr -f ${md}_complex.xtc \
		    	-cl ${md}_complex_clusters.pdb -cutoff 0.5 \
	        	-method gromos -dt 10 \
				-dist ${md}_complex_rmsd-dist.xvf \
				-o ${md}_complex_rmsd-clust.xpm <<END
Protein
System
END
           mv  "${md}_complex"*clust*.* ${md}_complex_rmsd-dist.xvf  "${md}_cluster"
	    fi
        # and now get the cluster average structures
	    if [ ! -e ${md}_complex_clustav.pdb ] ; then
            $g_cluster -s ${md}_complex.tpr -f ${md}_complex.xtc \
			    -cl ${md}_complex_clustav.pdb -cutoff 0.5 \
	            -method gromos -dt 10 -av \
				-dist ${md}_complex_av_rmsd-dist.xvf  \
				-o ${md}_complex_av_rmsd-clust.xpm <<END
Protein
System
END
            mv "${md}_complex_av_"* "${md}_cluster"
	    fi
    fi
	return 0
}



function xtc_compute_sas {
    md="$1"

    if [ ! -e "${md}.xtc" ] ; then return 1 ; fi
    if [ ! -e "${md}.tpr" ] ; then return 2 ; fi

    # protein surface area
    if [ ! -e ${md}_protein_sasa.xvg ] ; then
        boldblue "Computing SAS (Solvent Accessible Surface)"
        $g_sas -s ${md}.tpr -f ${md}.xtc -o ${md}_protein_sasa.xvg -tv ${md}_protein_vol.xvg <<END
Protein
Protein
END
        $grace -hardcopy -hdevice SVG -printfile ${md}_protein_sasa.SVG ${md}_protein_sasa.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_protein_sasa.PNG ${md}_protein_sasa.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice SVG -printfile ${md}_protein_vol.SVG ${md}_protein_vol.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_protein_vol.PNG ${md}_protein_vol.xvg -pexec 'runavg(S0,100)'
    fi    
    mkdir sas
    mv "${md}_protein_sasa."* "${md}_protein_vol."* sas
}



function xtc_analyze_ligands {
# THIS FUNCTION NEEDS CAREFUL REVIEW (*** JR ***)
    md="$1"
    ligands="$2"
    
    # count H-bonds (protein vs. ligands)
    #	Luckily, when the Complex is generated a group named 'Other'
    #	is generated that includes all non-protein elements (without solvent)
    #
    # $ligands is a file listing in each line one ligand with its charge
    if [ -s $ligands ] ; then
        echo ""
        echo ">>> Analyzing ligands and ligand interactions"
        echo ""

	#
        # ligand (non-protein) RMSD and RMSF
    	#
	if [ ! -e ${md}_nonprot_rmsd.xvg ] ; then
            $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsd.xvg -tu ns <<END
non-Protein
non-Protein
END
	    $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsd.SVG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	    $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsd.PNG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	fi
        if [ ! -e ${md}_nonprot_rmsf.xvg ] ; then
            echo "non-Protein"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsf.xvg -oq ${md}_nonprot_rmsf.pdb
            $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsf.SVG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
            $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsf.PNG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
	fi
        
        while read lig charge ; do
            # for each ligand
            if [ ! -e ${md}_${lig}_rmsd.xvg ] ; then
                $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsd.xvg -tu ns <<END
$lig
$lig
END
	        $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsd.SVG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	        $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsd.PNG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	    fi
            if [ ! -e ${md}_${lig}_rmsf.xvg ] ; then
                echo "$lig"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsf.xvg -oq ${md}_${lig}_rmsf.pdb
                $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsf.SVG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
                $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsf.PNG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
	    fi
        done <$ligands
        

	#
        # H-bonds between Protein and ligands
        #
        $g_hbond -f $md.xtc -s $md.tpr \
	        -num ${md}_hbnum.xvg -ac ${md}_hbac.xvg \
                <<END
Protein
Other
END
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbnum.SVG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbnum.PNG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbac.SVG ${md}_hbac.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbac.PNG ${md}_hbac.xvg -pexec 'runavg(S0,100)'

        # for each ligand
        #
        #	XXX JR XXX HACK HACK HACK HACK HACK HACK
        #
        #	WE HAVE A PROBLEM if Solvent has been used:
        #	gromacs duplicates the ligand groups, and so we cannot
        #	select them independently by name
        #
        #	On the other hand: the motivating behaviour is
        #	a known bug in Gromacs that has been assigned
        #	low priority because groups can still be selected
        #	by number.
        #
        #	use $md_complex.gro if it exists (implies solvent existed)
        #	  to make an index file without solvent interference
        #	else use $md.ndx instead (if there is no solvent there is no problem)
        #
        #	We could use the index of Complex_b4ion.pdb or Complex.pdb as a guide
        #	instead. This works because solvent is added AFTER the original 
        #	Complex and, so, the coordinate offsets in Complex.pdb are preserved.
        #	But that would imply using a hardcoded value and is a 'no-no'.
        #
        grep -q "^\[ SOL" $md.ndx
        if [ $? -eq 0 ] ; then
            echo "q" | $make_ndx -f ${md}_complex.pdb -o ${md}_complex.ndx
            ndx=${md}_complex.ndx
        else
            ndx=$md.ndx
        fi
        #
        while read lig charge ; do
            if [ ! -e ${md}_hb_${lig}_num.xvg ] ; then
                $g_hbond -f $md.xtc -s $md.tpr -n $ndx\
	                -num ${md}_hb_${lig}_num.xvg -ac ${md}_hb_${lig}_ac.xvg \
                        <<END
Protein
$lig
END
    	        $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_num.SVG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
    	        $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_num.PNG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_ac.SVG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_ac.PNG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
	    fi
        done < $ligands

	#
        # Solvent Accessible Surface Area and volume
        #
	
        # we need different commands for Protein and Protein+ligans
        if [ -s Ligands.pdb ] ; then
            # create an index of protein plus all ligands
            #	This works because group Other was created before addition
            #	of water and contains only the ligands with no solvent
            $make_ndx  -f ${md}.tpr -o pro+lig.ndx <<END
"Protein"|"Other"
q
END
            # use the extended group to compute an "extended" protein
            # surface area (protein + ligands)
            $g_sas -s ${md}.tpr -f ${md}.xtc -o ${md}_complex_sasa.xvg -tv ${md}_complex_vol.xvg \
    	        -n pro+lig.ndx <<END
Protein_Other
Protein_Other
END
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_sasa.SVG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_sasa.PNG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_vol.SVG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_vol.PNG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
	fi

    fi
}


function xvg2img {
    x="$1"
	
    n=${x%.xvg}
	ext=${x##*.}
	# we want an XVG file
	if [ "$ext" != "xvg" ] ; then return 1 ; fi
	# which, obviously, must exist and not be empty
	if [ ! -s "$x" ] ; then return 2 ; fi
	
	# do not repeat work already done
    if [ ! -e ${n}.SVG ] ; then
        $grace -hardcopy -hdevice SVG -printfile ${n}.SVG ${i}
    fi
    if [ ! -e ${n}.PNG ] ; then
        $grace -hardcopy -hdevice PNG -printfile ${n}.PNG ${i}
    fi
	return 0
}



# convert a .GRO file to .PDB
#	Optionally allows to specify a subset of the system (with a .NDX file)
#	and the method to use to deal with PBC
# By default this will extract all the system making molecules whole
#
function gro2pdb {
    local gro="${1:-struct.gro}"
    local subset="${2:-System}"
    local pbc="${3:-whole}"
    
    local gf="$gro"
    local gn="${gf%.*}"
    local ge="${gf##*.}"
    local ndx=''
    
    if [ ! -s "$gro" ] ; then return 1 ; fi
    if [ -e "$gn.ndx" ] ; then ndx="-n $gn.ndx" ; fi

    if [ "$ge" == "gro" ] ; then
        if [ -e "$gn.tpr" ] ; then
            if [ "$subset" != "System" ] ; then on="${gn}_${subset}" ; else on="$gn" ; fi
            echo "$subset" \
            | gmx trjconv -f "$gf" -s "$gn.tpr" -o "$on.pdb" \
                -pbc "${pbc}" -center \
                ${comment# -pbc mol -center } \
                -ur compact -conect $ndx
                # -pbc whole: make broken molecules whole
                # -pbc mol: puts the center of mass of molecules in the box
                #			(may have limited effect in solvated boxes --check)
                # -pbc nojump: checks if atoms jump across the box and then 
                #			puts them back. This has the effect that all 
                #			molecules will remain whole (provided they were 
                #			whole in the initial conformation). Note that this 
                #			ensures a continuous trajectory but molecules may 
                #			diffuse out of the box
                # -pbc res	puts the center of mass of residues in the box.
                #
                # -ur sets the unit cell representation, compact puts all 
                #			atoms at the closest distance from the center 
                #			of the box.
                #
                # -center	centers the system in the box (may have limited
                #			effect on solvated boxes --check)
        else
            # no way we can select a subset
            gmx editconf -f "$gf" -o "$gn.pdb" -pbc "$pbc"
        fi
    elif [ "$ge" == ".brk" -o "$ge" == "ent" ] ; then
        cp "$gf" "$gn".pdb
    else
        echo "gro2pdb: unknown structure format (.$ge)"
    fi

    return 0
}




function analyze_md_run {
    # arguments: MD run base name
    # requirements:
    #	$md.tpr		-- topology file
    #   $md.gro         -- final coordinates	(optional)
    #	$md.trr		-- original trajectory file
    #	$md.xtc		-- low-res trajectory file	(optional)
    #   ${md}_noPBC.xtc	-- low-res trajectory corrected for PBC	(optional)
    #	$md.edr		-- energy evolution	
    #
    #	Complex_water.pdb if water was used in the simulation
    #
    local md=$1
    local ligands=${2:-LIGANDS.ok}
    
    echo ""
    boldblue "analyze_md_run: Analyzing MD run: $md"
    echo ""
    
    # Minimization runs do not generate trajectories
    if [ ! -e $md.trr ] ; then
    	boldred "analyze_md_run ERROR: No trajectory found for MD run \"$md\"."
        return
    fi
    if [ -e ${md}.analyzed ] ; then
        boldblue "analyze_md_run: MD run \"${md}\" is already analyzed"
        boldblue "analyze_md_run: remove file $md.analyzed to re-analyze"
        return
    fi
    
    # ensure we have definitions of solute, solvent and chains
    if [ ! -e $md.ndx ] ; then
        boldblue "Building index"
        make_ext_index "$md"
    fi
    
    boldblue "Creating XTC file"
    if [ ! -e "${md}.xtc" ] ; then
	    # convert to XTC and save last time as $md.lastt
	    trr_to_xtc "$md"
    fi
	# save last time registered in the trajectory
    if [ ! -e "${md}.lastt" ] ; then
	     # save trajectory last time to $md.lastt
	    xtc_last_time "$md"
    fi
    # get last time in the trajectory
    lastt=`cat "$md.lastt"`

    # get last configuration if not present from high-res trajectory
    if [ ! -e ${md}_last.gro ] ; then
	    trr_struct_at_t "$md" "-1"
		if [ ! -e "$md.gro" ] ; then ln "${md}_last.gro" "${md}.gro" ; fi
    fi
    
    # fit trajectory using first frame as reference
	# and save as ${md}_fit.xtc
    if [ ! -e ${md}_fit.xtc ] ; then
	    xtc_fit "$md"
    fi
    
    # correct trajectory for PBC if needed
	# generating ${md}_noPBC.xtc and ${md}_noPBC.tpr
    if [ ! -e ${md}_noPBC.xtc ] ; then
	    xtc_fix_pbc "$md"
    fi


    # Remove solvent (will do it with ${md}_noPBC (see function above)
	# and save first and last configurations of the solvent-free complex
	if [ ! -e "${md}_complex.xtc" ] ; then
	    xtc_remove_solvent "$md"
	fi
	
    boldblue "Fitting system to itself"
    if [ ! -e ${md}_complex_fit.xtc ] ; then
        xtc_fit "${md}_complex"
    fi
    
    xtc_analyze_covariance "$md"
	#-comp -rmsf -eig -proj -2d -3d #-extr
	#gmx analyze
    
    # check for ring flips (e.g. Phe/Tyr)
    xtc_check_ring_flips "$md"    


    # Compute various graphs
    xtc_plot_evolution "$md"

    #	1. RMSD (movement w.r.t. original conformation)
    #	Show structural stability using ns as time unit
	xtc_compute_rmsd "${md}_complex_fit"

    #	2. RMSF (movility per atom/residue)
    #	    
    xtc_compute_rmsf "${md}_complex_fit"
	

    #	3. Radius of gyration (compactness and stability of the structure)
    #	backbone
    # The radius of gyration of a protein is a measure of its compactness. If a 
    # protein is stably folded, it will likely maintain a relatively steady value 
    # of R_g. If a protein unfolds, its R_g will change over time. 
    #
	xtc_compute_gyr_acf "$md_complex"
    
	
    
    #	4. Compute secondary structure changes
    #
	xtc_compute_secondary_structure "${md}_complex"

    #	5. Clusterize trajectory and output central structures in
    #	each cluster.
    #g_cluster -s md_complex.tpr -f md_complex.trr -dist rmsd-distribution.xvg \
    #	-o clusters.xpm -sz cluster-sizes.xvg -tr cluster-transitions.xpm \
    #        -ntr cluster-transitions.xvg -clid cluster-id-over-time.xvg \
    #        -cl clusters.pdb -cutoff 0.25 -method gromos -dt 10 [ -av ]
    xtc_cluster "$md"
	
    # protein surface area
    xtc_compute_sas "$md"
 
    # for all ligands
    xtc_analyze_ligands "$md" "$ligands"

    boldblue "Doing any remaining plot"
    # Last resort to ensure all XVG files are plotted
    for x in *.xvg ; do 
        xvg2img $x
    done

    touch ${md}.analyzed

    boldblue "DONE"
}

if [ "$LIBRARY"="no" ] ; then
    if [ $# -eq 0 ] ; then
	echo "Usage: "`basename $0`" trajectory [ligands]"
	exit
    elif [ $# -eq 1 ] ; then
        # strip the last part after a hypothetical dot just in case?
        trajectory="$1"
        ligands=''
    else
        trajectory="$1"
	ligands="$2"
    fi
    
    LIBRARY="yes"
    BASE=~/work/lenjuanes/script
    . $BASE/setup_cmds.sh
    . $BASE/make_ext_index.sh
    

    if [ ! -s ${trajectory}.trr ] ; then
	echo "MD trajectory $md.trr does not exist!"
	exit
    fi


    # work on a subdirectory
    mkdir "${trajectory}_analysis"
    cd "${trajectory}_analysis"
    for i in ../$trajectory.* ../${trajectory}_noPBC* ; do
	    if [ ! -s $i ] ; then continue ; fi
        if [ ! -e `basename $i` ] ; then
	    ln -s $i `basename $i`
 	fi
    done
     
    analyze_md_run $*

    cd ..
fi
